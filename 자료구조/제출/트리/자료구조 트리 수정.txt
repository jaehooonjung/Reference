#include<iostream>
#include<string>
#include<conio.h>
#include<Windows.h>
#define LEFT 0
#define RIGHT 1

using namespace std;

struct Tree
{
	int data;
	Tree*Left;
	Tree*Right;
};

void MenuDraw()
{
	cout << "1. data 추가" << endl;
	cout << "2. data 삭제" << endl;
	cout << "3. preorder" << endl;
	cout << "4. inorder" << endl;
	cout << "5. postorder" << endl;
	cout << "6. data 검색" << endl;
	cout << "7. 종료" << endl;
	cout << ">>>>>> ";
}


void Insert(Tree**Node, int data)
{
	if (*Node == NULL)
	{
		*Node = new Tree;
		(*Node)->data = data;
		(*Node)->Left = NULL;
		(*Node)->Right = NULL;
		return;
	}
	else
	{
		if ((*Node)->data == data)
		{
			cout << "중복된 데이터가 있습니다.";
			return;
		}
		else if ((*Node)->data > data)
		{
			Insert(&(*Node)->Left, data);
		}
		else if ((*Node)->data < data)
		{
			Insert(&(*Node)->Right, data);
		}
	}
}

bool NodeNullCheck(Tree*Node)
{
	if (Node == NULL)
	{
		cout << endl << "데이터가 없습니다.";
		return false;
	}
	else true;
}

void preorder(Tree**Node)
{
	if (NodeNullCheck(*Node) == false)
		return;

	cout << (*Node)->data << "\t";
	if ((*Node)->Left != NULL)
		preorder(&(*Node)->Left);
	if ((*Node)->Right != NULL)
		preorder(&(*Node)->Right);

}

void inorder(Tree**Node)
{
	if (NodeNullCheck(*Node) == false)
		return;

	if ((*Node)->Left != NULL)
		inorder(&(*Node)->Left);

	cout << (*Node)->data << "\t";

	if ((*Node)->Right != NULL)
		inorder(&(*Node)->Right);
}

void postorder(Tree**Node)
{
	if (NodeNullCheck(*Node) == false)
		return;
	if ((*Node)->Left != NULL)
		postorder(&(*Node)->Left);
	if ((*Node)->Right != NULL)
		postorder(&(*Node)->Right);
	cout << (*Node)->data << "\t";
}

Tree*serach(Tree**Node, int data)
{
	static Tree * Tmp;
	Tmp = NULL;

	if (NodeNullCheck(*Node) == false)
		return false;

	if ((*Node)->data > data)
	{
		if ((*Node)->Left != NULL)
			serach(&(*Node)->Left, data);
	}

	if ((*Node)->data == data)
	{
		Tmp = (*Node);
		return Tmp;
	}

	if ((*Node)->data < data)
	{
		if ((*Node)->Right != NULL)
			serach(&(*Node)->Right, data);
	}

	return Tmp;
}



void Delete(Tree**Node, int data)
{
	//if (NodeNullCheck(*Node) == false)
		//return;
	bool LRflag;
	Tree*pretmp = *Node;
	Tree*Deletetmp = serach(&(*Node), data);
	if (Deletetmp == NULL)
	{
		cout << "삭제하려는 데이터가 존제하지 않습니다.";
		return;
	}
	Tree*Leftdata = Deletetmp->Left;
	Tree*Rightdata = Deletetmp->Right;

	while (1)
	{
		if (data < pretmp->data)
		{
			if (pretmp->Left->data == data)
			{
				LRflag = LEFT;
				break;
			}
			else
				pretmp = pretmp->Left;

		}
		else if (pretmp->data < data)
		{
			if (pretmp->Right->data == data)
			{
				LRflag = RIGHT;
				break;
			}
			else
				pretmp = pretmp->Right;

		}
		else
		{
			pretmp = NULL;
		}
	}

	if (Leftdata != NULL && Rightdata == NULL)
	{
		delete Deletetmp;
		Deletetmp = NULL;
		if (LRflag == LEFT)
			pretmp->Left = Leftdata;
		else if (LRflag == RIGHT)
			pretmp->Right = Leftdata;
	}
	else if (Leftdata == NULL && Rightdata != NULL)
	{
		delete Deletetmp;
		Deletetmp = NULL;
		if (LRflag == LEFT)
			pretmp->Left = Rightdata;
		else if (LRflag == RIGHT)
			pretmp->Right = Rightdata;
	}
	else if (Leftdata != NULL && Rightdata != NULL)
	{
		Tree*MinPreTmp = Deletetmp->Right;
		Tree*MinTmp;

		if (MinPreTmp->Left == NULL)
		{
			pretmp->Right = Deletetmp->Left;
			MinPreTmp->Left = Deletetmp->Left;
			delete Deletetmp;
			return;
		}
		else
		{
			while (MinPreTmp->Left != NULL)
			{
				if (MinPreTmp->Left->Left == NULL)
				{
					MinTmp = MinPreTmp->Left;
					break;
				}
				else
					MinPreTmp = MinPreTmp->Left;
			}
		}

		MinPreTmp->Left = MinTmp->Right;
		MinTmp->Right = NULL;

		if (LRflag == LEFT)
		{
			pretmp->Left = MinTmp;
			MinTmp->Right = Deletetmp->Right;
			MinTmp->Left = Deletetmp->Left;
		}
		else if (LRflag == RIGHT)
		{
			pretmp->Right = MinTmp;
			MinTmp->Left =Deletetmp->Right;
			MinTmp->Right = Deletetmp->Right;
		}
		delete Deletetmp;
	}
}


void AllDelete(Tree*Node)
{
	if (NodeNullCheck(Node) == false)
		return;
	else
	{
		if (Node->Left != NULL)
			AllDelete(Node->Left);
		if (Node->Right != NULL)
			AllDelete(Node->Right);
		delete Node;
		Node = NULL;
	}
}


void main()
{
	//_CrtSetDbgFlag(_CRTDBG_LEAK_CHECK_DF | _CRTDBG_ALLOC_MEM_DF);
	//_crtBreakAlloc = 1720;


	Tree *Node = NULL;
	Insert(&Node, 42);
	Insert(&Node, 62);
	Insert(&Node, 60);
	Insert(&Node, 80);
	Insert(&Node, 70);
	Insert(&Node, 75);
	Insert(&Node, 65);
	Insert(&Node, 68);
	Insert(&Node, 66);
	Insert(&Node, 67);
	Insert(&Node, 69);
	Insert(&Node, 63);


	int select, data;
	while (1)
	{
		system("cls");
		MenuDraw();
		cin >> select;
		switch (select)
		{
		case 1:
			cout << "추가할 데이터 입력 : ";
			cin >> data;
			Insert(&Node, data);
			break;
		case 2:
			cout << "삭제할 데이터 입력 : ";
			cin >> data;
			Delete(&Node, data);
			break;
		case 3:
			preorder(&Node);
			break;
		case 4:
			inorder(&Node);
			break;
		case 5:
			postorder(&Node);
			break;
		case 6:
			cout << "데이터 입력 : ";
			cin >> data;
			if (serach(&Node, data) != NULL)
				cout << "데이터가 있습니다.";
			else
				cout << "데이터가 없습니다.";
			break;
		case 7:
			AllDelete(Node);
			return;
		}
		system("pause");
	}

}